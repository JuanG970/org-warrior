#!/usr/bin/env python3
"""
org-warrior: A TaskWarrior-like CLI interface using org-ql as backend.
Executes org-ql queries via Emacs in batch mode.
"""

import subprocess
import sys
import os
import re
import shutil
from datetime import datetime, date
from typing import Optional, Tuple



def git_commit_org(message: str):
    """Auto-commit changes in ~/org if it's a git repo and there are modifications."""
    org_root = os.path.expanduser('~/org')
    if not os.path.isdir(os.path.join(org_root, '.git')):
        return
    # Only commit when there are changes
    st = subprocess.run(['git', '-C', org_root, 'status', '--porcelain'], capture_output=True, text=True)
    if st.returncode != 0:
        return
    if not st.stdout.strip():
        return
    subprocess.run(['git', '-C', org_root, 'add', '-A'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    subprocess.run(['git', '-C', org_root, 'commit', '-m', message], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)


# Configuration
ORG_FILES = os.environ.get("ORG_WARRIOR_FILES", "~/org")
EMACS_CMD = os.environ.get("EMACS_CMD", "emacsclient")
EMACS_SERVER = os.environ.get("ORG_WARRIOR_SERVER", "edit")
EMACS_LOAD_PATH = os.environ.get("ORG_WARRIOR_LOAD_PATH", "")

ANSI_RESET = "\033[0m"
ANSI_BOLD = "\033[1m"
ANSI_DIM = "\033[2m"
ANSI_RED = "\033[31m"
ANSI_GREEN = "\033[32m"
ANSI_YELLOW = "\033[33m"
ANSI_BLUE = "\033[34m"
ANSI_MAGENTA = "\033[35m"
ANSI_CYAN = "\033[36m"

TODO_COLORS = {
    "NEXT": ANSI_CYAN,
    "TODO": ANSI_GREEN,
    "WAITING": ANSI_MAGENTA,
    "PROJECT": ANSI_BLUE,
}

PRIORITY_COLORS = {
    "A": ANSI_RED,
    "B": ANSI_YELLOW,
    "C": ANSI_BLUE,
}

ORG_TS_RE = re.compile(r'(\d{4}-\d{2}-\d{2})(?:\s+\w+)?(?:\s+(\d{2}:\d{2}))?')
USE_COLOR = False


def supports_color() -> bool:
    return sys.stdout.isatty() and os.environ.get("NO_COLOR") is None


def set_color_mode(enabled: bool = True) -> None:
    global USE_COLOR
    USE_COLOR = enabled and supports_color()


def colorize(text: str, color: Optional[str], *, bold: bool = False, dim: bool = False) -> str:
    if not USE_COLOR:
        return text
    prefix = ""
    if bold:
        prefix += ANSI_BOLD
    if dim:
        prefix += ANSI_DIM
    if color:
        prefix += color
    if not prefix:
        return text
    return f"{prefix}{text}{ANSI_RESET}"


def parse_org_timestamp(value: Optional[str]) -> Tuple[Optional[date], Optional[str]]:
    if not value:
        return None, None
    match = ORG_TS_RE.search(value)
    if not match:
        return None, None
    date_str, time_str = match.groups()
    try:
        parsed_date = datetime.strptime(date_str, "%Y-%m-%d").date()
    except ValueError:
        return None, time_str
    return parsed_date, time_str


def date_status(value: Optional[date]) -> Optional[str]:
    if not value:
        return None
    today = date.today()
    if value < today:
        return "overdue"
    if value == today:
        return "today"
    return "future"


def date_color(kind: str, status: Optional[str]) -> Tuple[Optional[str], bool]:
    if not status:
        return None, False
    if kind == "DUE":
        if status == "overdue":
            return ANSI_RED, True
        if status == "today":
            return ANSI_YELLOW, True
        return ANSI_GREEN, False
    if status == "overdue":
        return ANSI_RED, False
    if status == "today":
        return ANSI_CYAN, False
    return ANSI_BLUE, False


def format_date_label(kind: str, value: Optional[str]) -> Optional[str]:
    if not value:
        return None
    parsed_date, _ = parse_org_timestamp(value)
    status = date_status(parsed_date)
    color, bold = date_color(kind, status)
    return colorize(f"{kind}:{value}", color, bold=bold)


def format_date_value(kind: str, value: Optional[str]) -> Optional[str]:
    if not value:
        return None
    parsed_date, _ = parse_org_timestamp(value)
    status = date_status(parsed_date)
    color, bold = date_color(kind, status)
    return colorize(value, color, bold=bold)


def get_doom_load_paths():
    """Get load paths for Doom Emacs straight packages."""
    home = os.path.expanduser("~")
    straight_dir = os.path.join(home, ".emacs.d", ".local", "straight")
    
    if not os.path.isdir(straight_dir):
        return []
    
    # Find build directory (e.g., build-30.2), exclude cache files
    build_dirs = [d for d in os.listdir(straight_dir) 
                  if d.startswith("build") and os.path.isdir(os.path.join(straight_dir, d))]
    if not build_dirs:
        return []
    
    build_dir = os.path.join(straight_dir, sorted(build_dirs)[-1])
    
    # Required packages for org-ql
    required = ["org-ql", "org", "dash", "s", "ts", "peg", "ov", 
                "org-super-agenda", "compat", "f", "ht", "map"]
    
    paths = []
    for pkg in required:
        pkg_path = os.path.join(build_dir, pkg)
        if os.path.isdir(pkg_path):
            paths.append(pkg_path)
    
    return paths


def build_load_path_elisp():
    """Build elisp to add load paths."""
    paths = []
    
    # Custom load path from environment
    if EMACS_LOAD_PATH:
        paths.extend(EMACS_LOAD_PATH.split(":"))
    
    # Auto-detect Doom Emacs
    paths.extend(get_doom_load_paths())
    
    if not paths:
        return ""
    
    elisp_parts = [f'(add-to-list \'load-path "{p}")' for p in paths]
    return " ".join(elisp_parts)


def resolve_org_files(files_spec):
    """Return a list of .org files from a file/dir or path-separated list, including nested."""
    if isinstance(files_spec, (list, tuple)):
        specs = files_spec
    else:
        specs = str(files_spec).split(os.pathsep)
    resolved = []
    for spec in specs:
        if not spec:
            continue
        path = os.path.expanduser(spec)
        if os.path.isdir(path):
            for root, _, filenames in os.walk(path):
                for fname in filenames:
                    if fname.endswith(".org"):
                        resolved.append(os.path.join(root, fname))
        elif os.path.isfile(path):
            resolved.append(path)
    # Deduplicate preserving first-seen order
    seen = set()
    unique = []
    for f in resolved:
        if f not in seen:
            seen.add(f)
            unique.append(f)
    return unique


def build_agenda_files_eval(files_spec):
    """Build elisp to set org-agenda-files from resolved paths."""
    files = resolve_org_files(files_spec)
    if not files:
        return None
    escaped_files = [f.replace('"', '\\"') for f in files]
    file_list = " ".join(f'"{f}"' for f in escaped_files)
    return f"(setq org-agenda-files '({file_list}))"


def run_org_ql(query, files=None, select="heading"):
    """Run an org-ql query via Emacs batch mode and return results."""
    files = files or ORG_FILES
    
    if select == "heading":
        select_expr = "(substring-no-properties (org-get-heading t t t t))"
    elif select == "full":
        select_expr = """(list (substring-no-properties (org-get-heading t t t t))
                              (org-entry-get nil "TODO")
                              (org-entry-get nil "PRIORITY")
                              (org-entry-get nil "DEADLINE")
                              (org-entry-get nil "SCHEDULED")
                              (buffer-file-name)
                              (line-number-at-pos)
                              (org-entry-get nil "ID"))"""
    else:
        select_expr = select

    load_paths = build_load_path_elisp()
    agenda_files_eval = build_agenda_files_eval(files)
    if not agenda_files_eval:
        print("Error: no org files found.", file=sys.stderr)
        return []

    elisp = f"""
(progn
  {load_paths}
  (require 'org-ql)
  (let ((results (org-ql-select (org-agenda-files)
                   '{query}
                   :action '{select_expr})))
    (mapconcat (lambda (r)
                 (if (listp r)
                     (format "%S" r)
                   (format "%s" r)))
               results
               "\\n")))
"""
    
    cmd = [
        EMACS_CMD, "-s", EMACS_SERVER, "-e", 
        f"(progn {agenda_files_eval} {elisp})"
    ]
    
    result = subprocess.run(cmd, capture_output=True, text=True)
    if result.returncode != 0 and result.stderr:
        errors = [l for l in result.stderr.split('\n') 
                  if l and not l.startswith('Loading') and 'Warning' not in l]
        if errors:
            print(f"Error: {' '.join(errors)}", file=sys.stderr)
    
    # emacsclient returns the result wrapped in quotes, strip them
    output = result.stdout.strip()
    if output.startswith('"') and output.endswith('"'):
        output = output[1:-1]
    # Unescape newlines and quotes
    output = output.replace('\\n', '\n').replace('\\"', '"')
    return output.split('\n') if output else []


def parse_result(line):
    """Parse a result line from org-ql output."""
    if line.startswith('('):
        # Format: ("heading" "TODO" "A" deadline scheduled "filepath" lineno "ID")
        # Deadline/scheduled/ID can be nil or "<date>"/"string"
        match = re.match(
            r'\("([^"]*)" (nil|"[^"]*") "([^"]*)" (nil|"[^"]*") (nil|"[^"]*") "([^"]*)" (\d+) (nil|"[^"]*")\)',
            line
        )
        if match:
            heading, todo, priority, deadline, scheduled, filepath, lineno, org_id = match.groups()
            return {
                'heading': heading,
                'todo': None if todo == 'nil' else todo.strip('"'),
                'priority': priority if priority and priority != 'B' else None,  # B is default
                'deadline': deadline.strip('"') if deadline != 'nil' else None,
                'scheduled': scheduled.strip('"') if scheduled != 'nil' else None,
                'file': filepath,
                'line': int(lineno),
                'id': org_id.strip('"') if org_id != 'nil' else None
            }
    return {'heading': line}


def format_task(task, idx=None, show_ids=False):
    """Format a task for display."""
    parts = []
    if idx is not None:
        parts.append(colorize(f"{idx:3d}", None, dim=True))
    
    if task.get('todo'):
        todo = task['todo']
        todo_color = TODO_COLORS.get(todo)
        parts.append(colorize(f"[{todo}]", todo_color, bold=True))
    
    if task.get('priority'):
        priority = task['priority']
        pri_color = PRIORITY_COLORS.get(priority)
        parts.append(colorize(f"({priority})", pri_color, bold=True))
    
    parts.append(colorize(task.get('heading', ''), None, bold=True))
    
    deadline = format_date_label("DUE", task.get('deadline'))
    scheduled = format_date_label("SCH", task.get('scheduled'))
    if deadline:
        parts.append(deadline)
    if scheduled and not deadline:
        parts.append(scheduled)
    
    if show_ids:
        org_id = task.get('id')
        if org_id:
            parts.append(colorize(f"ID:{org_id}", None, dim=True))
        else:
            parts.append(colorize("ID:", None, dim=True))
    
    return ' '.join(parts)


def format_task_detail(task, idx=None):
    """Format a task with file/line details."""
    lines = []
    prefix = f"Task {idx}:" if idx is not None else "Task:"
    lines.append(prefix)
    heading = task.get('heading', '')
    todo = task.get('todo')
    priority = task.get('priority')
    if todo:
        heading = f"{colorize(f'[{todo}]', TODO_COLORS.get(todo), bold=True)} {heading}"
    if priority:
        heading = f"{colorize(f'({priority})', PRIORITY_COLORS.get(priority), bold=True)} {heading}"
    lines.append(f"  {colorize(heading, None, bold=True)}")
    if task.get('deadline'):
        lines.append(f"  Deadline: {format_date_value('DUE', task['deadline'])}")
    if task.get('scheduled'):
        lines.append(f"  Scheduled: {format_date_value('SCH', task['scheduled'])}")
    file_info = task.get('file')
    line_no = task.get('line')
    if file_info and line_no:
        lines.append(f"  Location: {colorize(f'{file_info}:{line_no}', None, dim=True)}")
    return "\n".join(lines)


def print_results(results, empty_msg="No tasks found.", show_ids=False):
    """Print formatted results."""
    if not results or (len(results) == 1 and not results[0]):
        print(empty_msg)
        return 0
    
    for i, line in enumerate(results, 1):
        task = parse_result(line)
        print(format_task(task, i, show_ids=show_ids))
    
    print(f"\n{len(results)} task(s)")
    return len(results)


def cmd_task(args):
    """Show details for a single task by index from the given query (default list)."""
    if not args:
        print("Usage: org-warrior task <id> [filters]", file=sys.stderr)
        return
    try:
        idx = int(args[0])
    except ValueError:
        print("Error: task id must be a number.", file=sys.stderr)
        return
    query = build_query(args[1:])
    results = run_org_ql(query, select="full")
    if idx < 1 or idx > len(results):
        print(f"Task id {idx} out of range (1-{len(results)}).", file=sys.stderr)
        return
    task = parse_result(results[idx - 1])
    print(format_task_detail(task, idx))


def cmd_list(args):
    """List tasks matching filters."""
    show_ids = False
    if args and args[0] in ['--ids', '--show-ids']:
        show_ids = True
        args = args[1:]
    query = build_query(args)
    results = run_org_ql(query, select="full")
    print_results(results, show_ids=show_ids)


def cmd_next(args):
    """Show next actions (NEXT keyword or high priority TODO)."""
    query = '(or (todo "STRT") (and (todo "TODO") (priority "A")))'
    results = run_org_ql(query, select="full")
    print_results(results, "No next actions found.")


def cmd_today(args):
    """Show tasks due/scheduled up to today (overdue + today)."""
    show_ids = False
    if args and args[0] in ['--ids', '--show-ids']:
        show_ids = True
        args = args[1:]
    # Include overdue deadlines/scheduled items as well as items happening today.
    # Exclude DONE/CANCELLED via (not (done)).
    query = '(and (not (done)) (or (deadline :to today) (scheduled :to today) (ts-active :on today)))'
    results = run_org_ql(query, select="full")
    print_results(results, "No tasks for today.", show_ids=show_ids)


def cmd_week(args):
    """Show tasks for the coming week."""
    query = '(or (deadline :from today :to +7) (scheduled :from today :to +7))'
    results = run_org_ql(query, select="full")
    print_results(results, "No tasks for this week.")


def cmd_overdue(args):
    """Show overdue tasks."""
    query = '(and (not (done)) (deadline :to -1))'
    results = run_org_ql(query, select="full")
    print_results(results, "No overdue tasks.")


def cmd_done(args):
    """Show recently completed tasks."""
    query = '(closed :from -7 :to today)'
    results = run_org_ql(query, select="full")
    print_results(results, "No recently completed tasks.")


def cmd_projects(args):
    """Show active projects."""
    query = '(and (tags "project") (not (done)) (not (ancestors (tags "project"))))'
    results = run_org_ql(query, select="full")
    print_results(results, "No active projects.")


def cmd_search(args):
    """Search tasks by text."""
    if not args:
        print("Usage: org-warrior search <pattern>", file=sys.stderr)
        return
    
    pattern = ' '.join(args)
    query = f'(regexp "{pattern}")'
    results = run_org_ql(query, select="full")
    print_results(results, f"No tasks matching '{pattern}'.")


def cmd_tag(args):
    """List tasks with a specific tag."""
    if not args:
        print("Usage: org-warrior tag <tagname>", file=sys.stderr)
        return
    
    tag = args[0]
    query = f'(and (not (done)) (tags "{tag}"))'
    results = run_org_ql(query, select="full")
    print_results(results, f"No tasks with tag '{tag}'.")


def cmd_priority(args):
    """List tasks by priority."""
    pri = args[0].upper() if args else "A"
    query = f'(and (not (done)) (priority "{pri}"))'
    results = run_org_ql(query, select="full")
    print_results(results, f"No priority {pri} tasks.")


def cmd_waiting(args):
    """Show waiting tasks."""
    query = '(todo "WAIT")'
    results = run_org_ql(query, select="full")
    print_results(results, "No waiting tasks.")


def cmd_stuck(args):
    """Show stuck projects (projects without NEXT actions)."""
    query = '(and (tags "project") (not (done)) (not (ancestors (tags "project"))) (not (descendants (todo "STRT"))))'
    results = run_org_ql(query, select="full")
    print_results(results, "No stuck projects.")


def cmd_query(args):
    """Run a raw org-ql query."""
    if not args:
        print("Usage: org-warrior query '<org-ql-expression>'", file=sys.stderr)
        return
    
    query = ' '.join(args)
    results = run_org_ql(query, select="full")
    print_results(results, "No results.")


def cmd_start(args):
    """Clock in to a task by ID from a filter context."""
    if not args:
        print("Usage: org-warrior start <filter> <task-id>", file=sys.stderr)
        print("Example: org-warrior start today 1", file=sys.stderr)
        return
    
    # Last argument should be the task ID
    try:
        task_id = int(args[-1])
        filter_args = args[:-1]
    except ValueError:
        print("Error: last argument must be a task ID (number).", file=sys.stderr)
        return
    
    # Determine the query based on filter
    if not filter_args:
        query = '(and (todo) (not (done)))'
    elif filter_args[0] == 'today':
        query = '(and (not (done)) (or (deadline :to today) (scheduled :to today) (ts-active :on today)))'
    elif filter_args[0] == 'next':
        query = '(or (todo "STRT") (and (todo "TODO") (priority "A")))'
    elif filter_args[0] == 'week':
        query = '(or (deadline :from today :to +7) (scheduled :from today :to +7))'
    else:
        query = build_query(filter_args)
    
    # Get the list of tasks
    results = run_org_ql(query, select="full")
    
    if not results or (len(results) == 1 and not results[0]):
        print("No tasks found for the given filter.", file=sys.stderr)
        return
    
    if task_id < 1 or task_id > len(results):
        print(f"Task ID {task_id} out of range (1-{len(results)}).", file=sys.stderr)
        return
    
    # Parse the task to get file and line number
    task = parse_result(results[task_id - 1])
    filepath = task.get('file')
    lineno = task.get('line')
    
    if not filepath or not lineno:
        print("Error: could not determine task location.", file=sys.stderr)
        return
    
    # Build elisp to open file, go to line, and clock in
    elisp = f'''(progn
      (find-file "{filepath}")
      (goto-char (point-min))
      (forward-line {lineno - 1})
      (org-clock-in))'''
    
    cmd = [EMACS_CMD, "-s", EMACS_SERVER, "-e", elisp]
    
    result = subprocess.run(cmd, capture_output=True, text=True)
    
    if result.returncode != 0:
        print(f"Error clocking in: {result.stderr}", file=sys.stderr)
        return
    
    print(f"✓ Clocked in to task {task_id}: {task.get('heading')}")


def build_query(args):
    """Build org-ql query from TaskWarrior-like filters."""
    if not args:
        return '(and (todo) (not (done)))'
    
    conditions = ['(not (done))']
    
    for arg in args:
        if arg.startswith('+'):
            conditions.append(f'(tags "{arg[1:]}")')
        elif arg.startswith('project:'):
            conditions.append('(ancestors (tags "project"))')
        elif arg.startswith('pri:') or arg.startswith('priority:'):
            pri = arg.split(':')[1].upper()
            conditions.append(f'(priority "{pri}")')
        elif arg.startswith('due:'):
            due = arg.split(':')[1]
            if due == 'today':
                conditions.append('(deadline :on today)')
            elif due == 'week':
                conditions.append('(deadline :from today :to +7)')
            elif due == 'overdue':
                conditions.append('(deadline :to -1)')
        elif arg.startswith('scheduled:'):
            sched = arg.split(':')[1]
            if sched == 'today':
                conditions.append('(scheduled :on today)')
        else:
            conditions.append(f'(regexp "{arg}")')
    
    if len(conditions) == 1:
        return conditions[0]
    return f'(and {" ".join(conditions)})'





def emacs_eval(elisp: str) -> str:
    """Evaluate ELisp in the running Emacs daemon and return stdout (stripped)."""
    cmd = [EMACS_CMD, "-s", EMACS_SERVER, "-e", elisp]
    try:
        r = subprocess.run(cmd, capture_output=True, text=True, timeout=15)
    except subprocess.TimeoutExpired:
        raise RuntimeError('emacsclient timed out (Emacs may be busy or waiting for input)')
    if r.returncode != 0:
        raise RuntimeError((r.stderr or '').strip() or 'emacsclient eval failed')
    out = (r.stdout or '').strip()
    # emacsclient prints strings with quotes
    if out.startswith('"') and out.endswith('"'):
        out = out[1:-1]
    return out.replace('\\n', '\n').replace('\\"', '"')


def cmd_show(args):
    """Show a task by Org ID (preferred) or by list index (fallback)."""
    if not args:
        print("Usage: org-warrior show <ORG-ID> | show index <n> [filters]", file=sys.stderr)
        return
    if args[0] == 'index':
        return cmd_task(args[1:])
    org_id = args[0]
    # org-ql property query (fast, avoids org-id global scan)
    query = f'(property "ID" "{org_id}")'
    results = run_org_ql(query, select="full")
    if not results or (len(results) == 1 and not results[0]):
        print(f"No entry found for ID {org_id}")
        return
    task = parse_result(results[0])
    print(format_task_detail(task))



def cmd_add(args):
    """Add a new TODO to ~/org/inbox.org under 'Inbox' and create an org ID."""
    if not args:
        print("Usage: org-warrior add <title>", file=sys.stderr)
        return
    title = ' '.join(args).replace('\\', '\\\\').replace('"', '\\"')
    elisp = rf"""(progn
      (require 'org)
      (require 'org-id)
      (let* ((file (expand-file-name "~/org/inbox.org"))
             (heading "Inbox"))
        (find-file file)
        (goto-char (point-min))
        (unless (re-search-forward (format "^\\*+ %s\\b" (regexp-quote heading)) nil t)
          (goto-char (point-max))
          (insert (format "* %s\n" heading)))
        (org-end-of-subtree t t)
        (unless (bolp) (insert "\n"))
        (let ((pos (point)))
          (insert (format "** TODO %s\n" "{title}"))
          (goto-char pos)
          (org-id-get-create)
          (save-buffer)
          (princ (org-id-get)))))"""
    new_id = emacs_eval(elisp).strip()
    git_commit_org(f"org-warrior: add {new_id}")
    print(f"Created: {new_id}")


def cmd_set_state(args):
    """Set TODO state for an entry by Org ID."""
    if len(args) < 2:
        print("Usage: org-warrior set-state <ORG-ID> <STATE>", file=sys.stderr)
        return
    org_id, state = args[0], args[1]
    state = state.replace('"', '')
    elisp = rf"""(progn
      (require 'org)
      (require 'org-id)
      (let ((m (org-id-find "{org_id}" t)))
        (if (not m)
            (princ "NOT_FOUND")
          (with-current-buffer (marker-buffer m)
            (goto-char m)
            (org-todo "{state}")
            (save-buffer)
            (princ "OK")))))"""
    out = emacs_eval(elisp).strip()
    if out == 'NOT_FOUND':
        print(f"No entry found for ID {org_id}")
    else:
        git_commit_org(f"org-warrior: set-state {org_id} {state}")
        print("✓ Updated")


def cmd_schedule(args):
    """Schedule a task by filter and ID (e.g., org-warrior schedule "6pm" today 1) or by Org ID."""
    if len(args) < 2:
        print("Usage: org-warrior schedule <DATE> [filter...] <task-index|org-id>", file=sys.stderr)
        print("Example: org-warrior schedule \"6pm\" today 1", file=sys.stderr)
        print("Example: org-warrior schedule \"+1d\" +work 2", file=sys.stderr)
        print("Example: org-warrior schedule \"6pm\" abc123def456", file=sys.stderr)
        return
    
    date = args[0].replace('"', '')
    
    # Check if last argument is an Org ID (not an integer)
    try:
        task_id = int(args[-1])
        is_org_id = False
        filter_args = args[1:-1]
    except ValueError:
        # Last argument is not an int, treat as Org ID
        org_id = args[-1]
        is_org_id = True
    
    if is_org_id:
        # Schedule by Org ID directly using org-id-find
        elisp = f'''(progn
          (require 'org)
          (require 'org-id)
          (let ((m (org-id-find "{org_id}" t)))
            (if (not m)
                (princ "NOT_FOUND")
              (with-current-buffer (marker-buffer m)
                (goto-char m)
                (let ((d (format-time-string "%Y-%m-%d %H:%M" (org-read-date nil t "{date}"))))
                  (org-schedule nil d))
                (save-buffer)
                (princ (format "%s" (substring-no-properties (org-get-heading t t t t))))))))'''
        
        try:
            heading = emacs_eval(elisp).strip()
        except RuntimeError as e:
            print(f"Error scheduling: {e}", file=sys.stderr)
            return
        
        if heading == 'NOT_FOUND':
            print(f"No entry found for ID {org_id}", file=sys.stderr)
            return
        
        print(f"✓ Scheduled task: {heading}")
        return
    
    # Original numeric index path
    # Determine the query based on filter
    if not filter_args:
        query = '(and (todo) (not (done)))'
    elif filter_args[0] == 'today':
        query = '(and (not (done)) (or (deadline :to today) (scheduled :to today) (ts-active :on today)))'
    elif filter_args[0] == 'next':
        query = '(or (todo "STRT") (and (todo "TODO") (priority "A")))'
    elif filter_args[0] == 'week':
        query = '(or (deadline :from today :to +7) (scheduled :from today :to +7))'
    else:
        query = build_query(filter_args)
    
    # Get the list of tasks
    results = run_org_ql(query, select="full")
    
    if not results or (len(results) == 1 and not results[0]):
        print("No tasks found for the given filter.", file=sys.stderr)
        return
    
    if task_id < 1 or task_id > len(results):
        print(f"Task ID {task_id} out of range (1-{len(results)}).", file=sys.stderr)
        print("Note: Filtered indices may change after scheduling tasks.", file=sys.stderr)
        print("Consider using Org IDs for stable task references.", file=sys.stderr)
        print("Use 'org-warrior list --ids' or 'org-warrior today --ids' to see task IDs.", file=sys.stderr)
        return
    
    # Parse the task to get file and line number
    task = parse_result(results[task_id - 1])
    filepath = task.get('file')
    lineno = task.get('line')
    
    if not filepath or not lineno:
        print("Error: could not determine task location.", file=sys.stderr)
        return
    
    # Build elisp to open file, go to line, and schedule
    elisp = f'''(progn
      (find-file "{filepath}")
      (goto-char (point-min))
      (forward-line {lineno - 1})
      (let ((d (format-time-string "%Y-%m-%d %H:%M" (org-read-date nil t "{date}"))))
        (org-schedule nil d))
      (save-buffer))'''
    
    cmd = [EMACS_CMD, "-s", EMACS_SERVER, "-e", elisp]
    # Debug print
    # print(f"Running command: {' '.join(cmd)}")
    
    result = subprocess.run(cmd, capture_output=True, text=True)
    
    if result.returncode != 0:
        print(f"Error scheduling: {result.stderr}", file=sys.stderr)
        return
    
    # git_commit_org(f"org-warrior: schedule {task.get('heading')} {date}")
    print(f"✓ Scheduled task {task_id}: {task.get('heading')}")


def cmd_deadline(args):
    """Set a deadline for a task by filter and ID or by Org ID."""
    if len(args) < 2:
        print("Usage: org-warrior deadline <DATE> [filter...] <task-index|org-id>", file=sys.stderr)
        print("Example: org-warrior deadline \"friday\" today 1", file=sys.stderr)
        print("Example: org-warrior deadline \"+7d\" +work 2", file=sys.stderr)
        print("Example: org-warrior deadline \"friday\" abc123def456", file=sys.stderr)
        return
    
    date = args[0].replace('"', '')
    
    # Check if last argument is an Org ID (not an integer)
    try:
        task_id = int(args[-1])
        is_org_id = False
        filter_args = args[1:-1]
    except ValueError:
        # Last argument is not an int, treat as Org ID
        org_id = args[-1]
        is_org_id = True
    
    if is_org_id:
        # Set deadline by Org ID directly using org-id-find
        elisp = f'''(progn
          (require 'org)
          (require 'org-id)
          (let ((m (org-id-find "{org_id}" t)))
            (if (not m)
                (princ "NOT_FOUND")
              (with-current-buffer (marker-buffer m)
                (goto-char m)
                (let ((d (org-read-date nil nil "{date}")))
                  (org-deadline nil d))
                (save-buffer)
                (princ (format "%s" (substring-no-properties (org-get-heading t t t t))))))))'''
        
        try:
            heading = emacs_eval(elisp).strip()
        except RuntimeError as e:
            print(f"Error setting deadline: {e}", file=sys.stderr)
            return
        
        if heading == 'NOT_FOUND':
            print(f"No entry found for ID {org_id}", file=sys.stderr)
            return
        
        git_commit_org(f"org-warrior: deadline {heading} {date}")
        print(f"✓ Set deadline for task: {heading}")
        return
    
    # Original numeric index path
    # Determine the query based on filter
    if not filter_args:
        query = '(and (todo) (not (done)))'
    elif filter_args[0] == 'today':
        query = '(and (not (done)) (or (deadline :to today) (scheduled :to today) (ts-active :on today)))'
    elif filter_args[0] == 'next':
        query = '(or (todo "STRT") (and (todo "TODO") (priority "A")))'
    elif filter_args[0] == 'week':
        query = '(or (deadline :from today :to +7) (scheduled :from today :to +7))'
    else:
        query = build_query(filter_args)
    
    # Get the list of tasks
    results = run_org_ql(query, select="full")
    
    if not results or (len(results) == 1 and not results[0]):
        print("No tasks found for the given filter.", file=sys.stderr)
        return
    
    if task_id < 1 or task_id > len(results):
        print(f"Task ID {task_id} out of range (1-{len(results)}).", file=sys.stderr)
        print("Note: Filtered indices may change after setting deadlines.", file=sys.stderr)
        print("Consider using Org IDs for stable task references.", file=sys.stderr)
        print("Use 'org-warrior list --ids' or 'org-warrior today --ids' to see task IDs.", file=sys.stderr)
        return
    
    # Parse the task to get file and line number
    task = parse_result(results[task_id - 1])
    filepath = task.get('file')
    lineno = task.get('line')
    
    if not filepath or not lineno:
        print("Error: could not determine task location.", file=sys.stderr)
        return
    
    # Build elisp to open file, go to line, and set deadline
    elisp = f'''(progn
      (find-file "{filepath}")
      (goto-char (point-min))
      (forward-line {lineno - 1})
      (let ((d (org-read-date nil nil "{date}")))
        (org-deadline nil d))
      (save-buffer))'''
    
    cmd = [EMACS_CMD, "-s", EMACS_SERVER, "-e", elisp]
    
    result = subprocess.run(cmd, capture_output=True, text=True)
    
    if result.returncode != 0:
        print(f"Error setting deadline: {result.stderr}", file=sys.stderr)
        return
    
    git_commit_org(f"org-warrior: deadline {task.get('heading')} {date}")
    print(f"✓ Set deadline for task {task_id}: {task.get('heading')}")


def cmd_jira_sync(args):
    """Trigger org-jira sync inside Emacs. NOTE: hits external Jira service."""
    elisp = """(progn (require 'org-jira) (org-jira-get-issues) (princ "OK"))"""
    out = emacs_eval(elisp).strip()
    print("✓ Jira sync triggered" if out == 'OK' else out)


def print_help():
    """Print usage help."""
    help_text = """
org-warrior - TaskWarrior-like interface for org-ql

USAGE:
    org-warrior <command> [options]

COMMANDS:
    list [--ids] [filters]       List tasks (default command)
    show <ORG-ID>        Show details for a task by org ID (preferred)
    task <id> [filters]  Show details for a task by index
    next                 Show next actions
    today [--ids]        Tasks due/scheduled today
    week                 Tasks for the coming week
    overdue              Overdue tasks
    done                 Recently completed tasks
    projects             Active projects
    stuck                Stuck projects (no NEXT actions)
    waiting              Waiting tasks
    tag <name>           Tasks with specific tag
    priority <A|B|C>     Tasks by priority
    search <pattern>     Search tasks by text
    query <expr>         Run raw org-ql expression
    start <date> [filter] <id>     Clock in to a task
    schedule <date> [filter] <id|org-id>  Schedule a task
    deadline <date> [filter] <id|org-id>  Set deadline for a task
    add <title>          Add new TODO to inbox
    set-state <ORG-ID> <STATE>     Set TODO state by org ID
    jira-sync            Trigger org-jira sync

OPTIONS:
    --no-color          Disable colored output (also supports NO_COLOR)
    --ids, --show-ids   Show Org IDs in list/today commands

FILTERS (for list command):
    +tag              Filter by tag
    project:          Filter to project subtasks
    pri:A             Filter by priority
    due:today         Due today
    due:week          Due this week
    due:overdue       Overdue items
    scheduled:today   Scheduled today
    <text>            Text search

ENVIRONMENT:
    ORG_WARRIOR_FILES   Path(s) to org files or directories (os.pathsep-separated, recursive; default: ~/org)
    EMACS_CMD           Emacs command (default: emacsclient)
    ORG_WARRIOR_SERVER  Emacs server name (default: edit)

EXAMPLES:
    org-warrior                                   # List all open tasks
    org-warrior today --ids                       # Today's tasks with Org IDs
    org-warrior +work due:week                    # Work tasks due this week
    org-warrior search meeting                    # Search for 'meeting'
    org-warrior show index 1 scheduled:today      # Show first task from today's scheduled tasks
    org-warrior query '(todo "STRT")'             # Raw org-ql query
    org-warrior start today 1                     # Clock in to first task from today
    org-warrior schedule "6pm" today 1            # Schedule first task from today for 6pm
    org-warrior schedule "6pm" abc123def456       # Schedule task by Org ID
    org-warrior deadline "friday" +work 2         # Set deadline to friday for 2nd work task
"""
    print(help_text.strip())


def main():
    args = sys.argv[1:]
    
    if not args or args[0] in ['-h', '--help', 'help']:
        print_help()
        return

    if args[0] == '--no-color':
        set_color_mode(False)
        args = args[1:]
    else:
        set_color_mode(True)
    
    commands = {
        'list': cmd_list,
        'show': cmd_show,
        'task': cmd_task,
        'next': cmd_next,
        'today': cmd_today,
        'week': cmd_week,
        'overdue': cmd_overdue,
        'done': cmd_done,
        'projects': cmd_projects,
        'stuck': cmd_stuck,
        'waiting': cmd_waiting,
        'tag': cmd_tag,
        'priority': cmd_priority,
        'search': cmd_search,
        'query': cmd_query,
        'start': cmd_start,
        'schedule': cmd_schedule,
        'deadline': cmd_deadline,
        'jira-sync': cmd_jira_sync,
   
        'add': cmd_add,
    }
    
    cmd = args[0]
    cmd_args = args[1:]
    
    if cmd in commands:
        commands[cmd](cmd_args)
    else:
        cmd_list(args)


if __name__ == '__main__':
    main()
