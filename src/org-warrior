#!/usr/bin/env python3
"""
org-warrior: A TaskWarrior-like CLI interface using org-ql as backend.
Executes org-ql queries via Emacs in batch mode.
"""

import configparser
import subprocess
import sys
import os
import re
import shutil
import hashlib
import json
import tempfile
import uuid as _uuid
from datetime import datetime, date
from typing import Optional, Tuple


def git_commit_org(message: str):
    """Auto-commit changes in ~/org if it's a git repo and there are modifications."""
    org_root = os.path.expanduser('~/org')
    if not os.path.isdir(os.path.join(org_root, '.git')):
        return
    # Only commit when there are changes
    st = subprocess.run(['git', '-C', org_root, 'status', '--porcelain'], capture_output=True, text=True)
    if st.returncode != 0:
        return
    if not st.stdout.strip():
        return
    subprocess.run(['git', '-C', org_root, 'add', '-A'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    subprocess.run(['git', '-C', org_root, 'commit', '-m', message], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)


# Configuration: config file < env vars < CLI flags
CONFIG_DIR = os.path.expanduser("~/.org-warrior")
CONFIG_FILE = os.path.join(CONFIG_DIR, "config.toml")
CONTEXT_FILE = os.path.join(CONFIG_DIR, "context")


def _load_config():
    """Load INI config from ~/.org-warrior/config."""
    cfg = configparser.ConfigParser()
    if os.path.isfile(CONFIG_FILE):
        cfg.read(CONFIG_FILE)
    return cfg


_cfg = _load_config()

def _cfgval(section, key, default=""):
    try:
        return _cfg.get(section, key)
    except (configparser.NoSectionError, configparser.NoOptionError):
        return default


ORG_FILES = os.environ.get("ORG_WARRIOR_FILES", _cfgval("core", "files", "~/org"))
EMACS_CMD = os.environ.get("EMACS_CMD", _cfgval("core", "emacs_cmd", "emacsclient"))
EMACS_SERVER = os.environ.get("ORG_WARRIOR_SERVER", _cfgval("core", "server", "edit"))
EMACS_LOAD_PATH = os.environ.get("ORG_WARRIOR_LOAD_PATH", _cfgval("core", "load_path", ""))
EMACS_TIMEOUT = 15
DEFAULT_SORT = _cfgval("display", "default_sort", "")
DEFAULT_LIMIT = _cfgval("display", "default_limit", "")
CONFIG_COLOR = _cfgval("display", "color", "auto")
CONFIG_SHOW_HANDLES = _cfgval("display", "show_handles", "true").lower() != "false"
CONFIG_SHOW_IDS = _cfgval("display", "show_ids", "false").lower() == "true"

ANSI_RESET = "\033[0m"
ANSI_BOLD = "\033[1m"
ANSI_DIM = "\033[2m"
ANSI_RED = "\033[31m"
ANSI_GREEN = "\033[32m"
ANSI_YELLOW = "\033[33m"
ANSI_BLUE = "\033[34m"
ANSI_MAGENTA = "\033[35m"
ANSI_CYAN = "\033[36m"

TODO_COLORS = {
    "NEXT": ANSI_CYAN,
    "TODO": ANSI_GREEN,
    "WAITING": ANSI_MAGENTA,
    "PROJECT": ANSI_BLUE,
}

PRIORITY_COLORS = {
    "A": ANSI_RED,
    "B": ANSI_YELLOW,
    "C": ANSI_BLUE,
}

ORG_TS_RE = re.compile(r'(\d{4}-\d{2}-\d{2})(?:\s+\w+)?(?:\s+(\d{2}:\d{2}))?')
USE_COLOR = False

HANDLES_CACHE = os.path.expanduser("~/.org-warrior/handles.json")
WORDLIST_PATHS = [
    os.path.join(os.path.dirname(os.path.abspath(__file__)) if '__file__' in globals() else os.getcwd(), "wordlist.txt"),
    os.path.expanduser("~/.org-warrior/wordlist.txt"),
]
WORDLIST_DEFAULT = [
    "alpha", "bravo", "charlie", "delta", "echo", "foxtrot", "golf", "hotel",
    "india", "juliet", "kilo", "lima", "mike", "november", "oscar", "papa",
]
HANDLE_WORDS = 3
HANDLE_VERSION = 1


def supports_color() -> bool:
    return sys.stdout.isatty() and os.environ.get("NO_COLOR") is None


def set_color_mode(enabled: bool = True) -> None:
    global USE_COLOR
    USE_COLOR = enabled and supports_color()


def colorize(text: str, color: Optional[str], *, bold: bool = False, dim: bool = False) -> str:
    if not USE_COLOR:
        return text
    prefix = ""
    if bold:
        prefix += ANSI_BOLD
    if dim:
        prefix += ANSI_DIM
    if color:
        prefix += color
    if not prefix:
        return text
    return f"{prefix}{text}{ANSI_RESET}"


def load_wordlist() -> list:
    for path in WORDLIST_PATHS:
        if os.path.isfile(path):
            with open(path, "r", encoding="utf-8") as fh:
                words = [w.strip().lower() for w in fh if w.strip()]
            if words and (len(words) & (len(words) - 1) == 0):
                return words
            print(f"Warning: wordlist length must be power of two: {path}", file=sys.stderr)
    print("Warning: using fallback wordlist; handles may collide.", file=sys.stderr)
    return WORDLIST_DEFAULT


def _empty_handle_cache() -> dict:
    return {"version": HANDLE_VERSION, "by_handle": {}, "by_uuid": {}}


def load_handle_cache() -> dict:
    if not os.path.isfile(HANDLES_CACHE):
        return _empty_handle_cache()
    try:
        with open(HANDLES_CACHE, "r", encoding="utf-8") as fh:
            data = json.load(fh)
        if not isinstance(data, dict):
            return _empty_handle_cache()
        if "by_handle" not in data or "by_uuid" not in data:
            return _empty_handle_cache()
        return data
    except (OSError, json.JSONDecodeError):
        return _empty_handle_cache()


def save_handle_cache(cache: dict) -> None:
    os.makedirs(os.path.dirname(HANDLES_CACHE), exist_ok=True)
    fd, tmp_path = tempfile.mkstemp(prefix="handles-", dir=os.path.dirname(HANDLES_CACHE))
    try:
        with os.fdopen(fd, "w", encoding="utf-8") as fh:
            json.dump(cache, fh, indent=2, sort_keys=True)
        os.replace(tmp_path, HANDLES_CACHE)
    finally:
        if os.path.exists(tmp_path):
            os.unlink(tmp_path)


def _is_uuid(value: str) -> bool:
    try:
        _uuid.UUID(value)
        return True
    except ValueError:
        return False


def _word_indices_from_hash(hbytes: bytes, word_count: int) -> list:
    bits = int.from_bytes(hbytes, "big")
    word_bits = word_count.bit_length() - 1
    mask = (1 << word_bits) - 1
    indices = []
    for i in range(HANDLE_WORDS):
        shift = i * word_bits
        indices.append((bits >> shift) & mask)
    return indices


def _handle_from_uuid(uuid_str: str, wordlist: list) -> str:
    hbytes = hashlib.sha256(uuid_str.encode("utf-8")).digest()
    indices = _word_indices_from_hash(hbytes, len(wordlist))
    return "-".join(wordlist[i % len(wordlist)] for i in indices)


def ensure_handle_for_uuid(uuid_str: str, cache: dict, wordlist: list) -> Tuple[str, bool]:
    existing = cache["by_uuid"].get(uuid_str)
    if existing:
        return existing, False
    base_handle = _handle_from_uuid(uuid_str, wordlist)
    handle = base_handle
    counter = 1
    while handle in cache["by_handle"] and cache["by_handle"][handle] != uuid_str:
        handle = f"{base_handle}-{counter}"
        counter += 1
    cache["by_uuid"][uuid_str] = handle
    cache["by_handle"][handle] = uuid_str
    return handle, True


def resolve_id_token(token: str, cache: dict) -> Tuple[Optional[str], Optional[list]]:
    normalized = token.strip().lower()
    if normalized in cache["by_handle"]:
        return cache["by_handle"][normalized], None
    matches = [h for h in cache["by_handle"] if h.startswith(normalized)]
    if len(matches) == 1:
        return cache["by_handle"][matches[0]], None
    if len(matches) > 1:
        return None, sorted(matches)
    if _is_uuid(normalized) or any(ch.isdigit() for ch in normalized):
        return normalized, None
    return None, None


def ensure_handles_for_results(results: list) -> Tuple[dict, list, bool]:
    cache = load_handle_cache()
    wordlist = load_wordlist()
    updated = False
    tasks = []
    for line in results:
        task = parse_result(line)
        org_id = task.get("id")
        if org_id:
            handle, created = ensure_handle_for_uuid(org_id, cache, wordlist)
            task["handle"] = handle
            updated = updated or created
        tasks.append(task)
    return cache, tasks, updated


def scan_and_cache_handles() -> None:
    """Scan org files for existing IDs and populate handle cache. Warn about missing IDs."""
    
    print("Scanning org files for existing IDs...")
    
    # Option 1: Use Emacs org-map-entries for better integration (when available)
    try:
        emacs_eval("(+ 1 1)")  # Test connectivity
        print("Using Emacs for scanning...")
        
        scan_elisp = """(progn
  (require 'org)
  (let ((results '())
        (total-headings 0)
        (headings-with-ids 0)
        (headings-without-ids '()))
    (dolist (f (org-agenda-files))
      (condition-case err
        (with-current-buffer (find-file-noselect f)
          (org-map-entries
           (lambda ()
             (setq total-headings (1+ total-headings))
             (let ((id (org-entry-get nil "ID"))
                   (heading (org-get-heading t t t t))
                   (file (buffer-file-name))
                   (line (line-number-at-pos)))
               (if id
                   (progn
                     (setq headings-with-ids (1+ headings-with-ids))
                     (push (list "ID" id heading file line) results))
                 (push (list "NO_ID" "" heading file line) headings-without-ids))))
           nil 'file))
        (error (message "Error processing file %s: %s" f err))))
    (push (list "SUMMARY" total-headings headings-with-ids (length headings-without-ids)) results)
    (dolist (item (append results headings-without-ids))
      (princ (format "%s|%s|%s|%s|%s\\n" 
                     (nth 0 item) (nth 1 item) (nth 2 item) (nth 3 item) (nth 4 item))))))"""
        
        output = emacs_eval_with_agenda(scan_elisp, timeout=60)
        
        cache = load_handle_cache()
        wordlist = load_wordlist()
        updated = False
        found_ids = []
        missing_headings = []
        
        for line in output.splitlines():
            parts = line.strip().strip('"').split('|')
            if len(parts) >= 5:
                status, org_id, heading, file_path, line_num = parts
                
                if status == "SUMMARY":
                    total_headings = int(org_id)
                    headings_with_ids = int(heading)
                    headings_without = int(file_path)
                    print(f"Found {headings_with_ids} IDs out of {total_headings} headings")
                    if headings_without > 0:
                        print(f"âš ï¸  {headings_without} headings are missing IDs")
                elif status == "ID" and org_id:
                    found_ids.append(org_id)
                    _, created = ensure_handle_for_uuid(org_id, cache, wordlist)
                    updated = updated or created
                elif status == "NO_ID":
                    missing_headings.append((heading, file_path, line_num))
        
        # Show some examples of headings without IDs
        if missing_headings:
            print("\nExamples of headings without IDs:")
            for i, (heading, file_path, line_num) in enumerate(missing_headings[:5]):
                rel_path = os.path.relpath(file_path, os.path.expanduser("~"))
                print(f"  â€¢ {heading} ({rel_path}:{line_num})")
            if len(missing_headings) > 5:
                print(f"  ... and {len(missing_headings) - 5} more")
            
            print(f"\nðŸ’¡ To create missing IDs:")
            print("  1. Make sure your Emacs config has the org-warrior/ensure-ids-on-save hook")
            print("  2. Open and save the org files (IDs will be created automatically)")
            print("  3. Or use: SPC m i b (in Doom) to add IDs to current buffer")
        
    except Exception as e:
        # Fallback: Manual file parsing (no Emacs needed)
        print(f"Emacs not available, using file parsing... ({e})")
        
        cache = load_handle_cache()
        wordlist = load_wordlist()
        updated = False
        total_headings = 0
        found_ids = 0
        missing_examples = []
        
        files = resolve_org_files(ORG_FILES)
        for file_path in files:
            if not os.path.isfile(file_path):
                continue
                
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    lines = f.readlines()
                    
                for line_num, line in enumerate(lines, 1):
                    # Find headings
                    heading_match = re.match(r'^(\*+)\s+(.+)', line)
                    if heading_match:
                        total_headings += 1
                        heading_text = heading_match.group(2).strip()
                        
                        # Look for ID property in following lines
                        has_id = False
                        org_id = None
                        for i in range(line_num, min(line_num + 10, len(lines))):
                            if i < len(lines):
                                id_match = re.match(r'\s*:ID:\s+([a-fA-F0-9-]+)', lines[i])
                                if id_match:
                                    has_id = True
                                    org_id = id_match.group(1)
                                    break
                                # Stop looking if we hit another heading or end of properties
                                if re.match(r'^(\*+|\s*$)', lines[i]) and i != line_num:
                                    break
                        
                        if has_id and org_id:
                            found_ids += 1
                            _, created = ensure_handle_for_uuid(org_id, cache, wordlist)
                            updated = updated or created
                        elif len(missing_examples) < 5:  # Collect examples
                            rel_path = os.path.relpath(file_path, os.path.expanduser("~"))
                            missing_examples.append((heading_text, rel_path, line_num))
                            
            except Exception as e:
                print(f"Warning: Could not read {file_path}: {e}")
        
        print(f"Found {found_ids} IDs out of {total_headings} headings")
        
        if found_ids < total_headings:
            missing = total_headings - found_ids  
            print(f"âš ï¸  {missing} headings are missing IDs")
            
            if missing_examples:
                print("\nExamples of headings without IDs:")
                for heading, rel_path, line_num in missing_examples:
                    print(f"  â€¢ {heading} ({rel_path}:{line_num})")
                if missing > 5:
                    print(f"  ... and {missing - 5} more")
    
    if updated:
        save_handle_cache(cache)
    
    total_cached = len(cache.get('by_uuid', {}))
    print(f"\nâœ“ Handles cached: {total_cached}")
    
    if total_cached == 0:
        print("No Org IDs found. Make sure you have headings with IDs in your org files.")
    
    return


def parse_org_timestamp(value: Optional[str]) -> Tuple[Optional[date], Optional[str]]:
    if not value:
        return None, None
    match = ORG_TS_RE.search(value)
    if not match:
        return None, None
    date_str, time_str = match.groups()
    try:
        parsed_date = datetime.strptime(date_str, "%Y-%m-%d").date()
    except ValueError:
        return None, time_str
    return parsed_date, time_str


def date_status(value: Optional[date]) -> Optional[str]:
    if not value:
        return None
    today = date.today()
    if value < today:
        return "overdue"
    if value == today:
        return "today"
    return "future"


def date_color(kind: str, status: Optional[str]) -> Tuple[Optional[str], bool]:
    if not status:
        return None, False
    if kind == "DUE":
        if status == "overdue":
            return ANSI_RED, True
        if status == "today":
            return ANSI_YELLOW, True
        return ANSI_GREEN, False
    if status == "overdue":
        return ANSI_RED, False
    if status == "today":
        return ANSI_CYAN, False
    return ANSI_BLUE, False


def format_date_label(kind: str, value: Optional[str]) -> Optional[str]:
    if not value:
        return None
    parsed_date, _ = parse_org_timestamp(value)
    status = date_status(parsed_date)
    color, bold = date_color(kind, status)
    return colorize(f"{kind}:{value}", color, bold=bold)


def format_date_value(kind: str, value: Optional[str]) -> Optional[str]:
    if not value:
        return None
    parsed_date, _ = parse_org_timestamp(value)
    status = date_status(parsed_date)
    color, bold = date_color(kind, status)
    return colorize(value, color, bold=bold)


def get_doom_load_paths():
    """Get load paths for Doom Emacs straight packages."""
    home = os.path.expanduser("~")
    straight_dir = os.path.join(home, ".emacs.d", ".local", "straight")
    
    if not os.path.isdir(straight_dir):
        return []
    
    # Find build directory (e.g., build-30.2), exclude cache files
    build_dirs = [d for d in os.listdir(straight_dir) 
                  if d.startswith("build") and os.path.isdir(os.path.join(straight_dir, d))]
    if not build_dirs:
        return []
    
    build_dir = os.path.join(straight_dir, sorted(build_dirs)[-1])
    
    # Required packages for org-ql
    required = ["org-ql", "org", "dash", "s", "ts", "peg", "ov", 
                "org-super-agenda", "compat", "f", "ht", "map"]
    
    paths = []
    for pkg in required:
        pkg_path = os.path.join(build_dir, pkg)
        if os.path.isdir(pkg_path):
            paths.append(pkg_path)
    
    return paths


def build_load_path_elisp():
    """Build elisp to add load paths."""
    paths = []
    
    # Custom load path from environment
    if EMACS_LOAD_PATH:
        paths.extend(EMACS_LOAD_PATH.split(":"))
    
    # Auto-detect Doom Emacs
    paths.extend(get_doom_load_paths())
    
    if not paths:
        return ""
    
    elisp_parts = [f'(add-to-list \'load-path "{p}")' for p in paths]
    return " ".join(elisp_parts)


def _escape_elisp(s):
    """Escape a string for safe embedding inside elisp double-quoted strings."""
    return s.replace('\\', '\\\\').replace('"', '\\"')


def _unescape_elisp_string(s):
    """Unescape an elisp printed string (after removing outer quotes).

    Handles standard escape sequences produced by Emacs ``prin1``:
    ``\\\\`` â†’ ``\\``, ``\\\"`` â†’ ``\"``, ``\\n`` â†’ newline, ``\\t`` â†’ tab.
    """
    out = []
    i = 0
    while i < len(s):
        if s[i] == '\\' and i + 1 < len(s):
            c = s[i + 1]
            if c == 'n':
                out.append('\n')
            elif c == 't':
                out.append('\t')
            elif c == '"':
                out.append('"')
            elif c == '\\':
                out.append('\\')
            else:
                out.append(c)
            i += 2
        else:
            out.append(s[i])
            i += 1
    return ''.join(out)


def resolve_org_files(files_spec):
    """Return a list of .org files from a file/dir or path-separated list, including nested."""
    if isinstance(files_spec, (list, tuple)):
        specs = files_spec
    else:
        specs = str(files_spec).split(os.pathsep)
    resolved = []
    for spec in specs:
        if not spec:
            continue
        path = os.path.expanduser(spec)
        if os.path.isdir(path):
            for root, _, filenames in os.walk(path):
                for fname in filenames:
                    if fname.endswith(".org"):
                        resolved.append(os.path.join(root, fname))
        elif os.path.isfile(path):
            resolved.append(path)
    # Deduplicate preserving first-seen order
    seen = set()
    unique = []
    for f in resolved:
        if f not in seen:
            seen.add(f)
            unique.append(f)
    return unique


def build_agenda_files_eval(files_spec):
    """Build elisp to set org-agenda-files from resolved paths."""
    files = resolve_org_files(files_spec)
    if not files:
        return None
    escaped_files = [f.replace('"', '\\"') for f in files]
    file_list = " ".join(f'"{f}"' for f in escaped_files)
    return f"(setq org-agenda-files '({file_list}))"


def emacs_eval_with_agenda(elisp: str, timeout: int = 15) -> str:
    """Evaluate ELisp with org-agenda-files set."""
    load_paths = build_load_path_elisp()
    agenda_files_eval = build_agenda_files_eval(ORG_FILES)
    if not agenda_files_eval:
        raise RuntimeError("no org files found")
    cmd = [EMACS_CMD, "-s", EMACS_SERVER, "-e", f"(progn {load_paths} {agenda_files_eval} {elisp})"]
    try:
        r = subprocess.run(cmd, capture_output=True, text=True, timeout=timeout)
    except subprocess.TimeoutExpired:
        raise RuntimeError('emacsclient timed out (Emacs may be busy or waiting for input)')
    if r.returncode != 0:
        raise RuntimeError((r.stderr or '').strip() or 'emacsclient eval failed')
    out = (r.stdout or '').strip()
    if out.startswith('"') and out.endswith('"'):
        out = out[1:-1]
    return _unescape_elisp_string(out)


def run_org_ql(query, files=None, select="heading"):
    """Run an org-ql query via Emacs batch mode and return results."""
    files = files or ORG_FILES
    
    if select == "heading":
        select_expr = "(substring-no-properties (org-get-heading t t t t))"
    elif select == "full":
        select_expr = """(list (substring-no-properties (org-get-heading t t t t))
                              (org-entry-get nil "TODO")
                              (org-entry-get nil "PRIORITY")
                              (org-entry-get nil "DEADLINE")
                              (org-entry-get nil "SCHEDULED")
                              (buffer-file-name)
                              (line-number-at-pos)
                              (org-entry-get nil "ID"))"""
    else:
        select_expr = select

    load_paths = build_load_path_elisp()
    agenda_files_eval = build_agenda_files_eval(files)
    if not agenda_files_eval:
        print("Error: no org files found.", file=sys.stderr)
        return []

    elisp = f"""
(progn
  {load_paths}
  (require 'org-ql)
  (let ((results (org-ql-select (org-agenda-files)
                   '{query}
                   :action '{select_expr})))
    (mapconcat (lambda (r)
                 (if (listp r)
                     (format "%S" r)
                   (format "%s" r)))
               results
               "\\n")))
"""
    
    cmd = [
        EMACS_CMD, "-s", EMACS_SERVER, "-e", 
        f"(progn {agenda_files_eval} {elisp})"
    ]
    
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=EMACS_TIMEOUT)
    except subprocess.TimeoutExpired:
        print("Error: emacsclient timed out (Emacs may be busy or waiting for input).", file=sys.stderr)
        return []
    if result.returncode != 0 and result.stderr:
        errors = [l for l in result.stderr.split('\n')
                  if l and not l.startswith('Loading') and 'Warning' not in l]
        if errors:
            print(f"Error: {' '.join(errors)}", file=sys.stderr)
    
    # emacsclient returns the result wrapped in quotes; unescape the
    # elisp printed string properly so inner s-expression escaping is
    # preserved for the tokenizer.
    output = result.stdout.strip()
    if output.startswith('"') and output.endswith('"'):
        output = output[1:-1]
    output = _unescape_elisp_string(output)
    return output.split('\n') if output else []


def _tokenize_sexp(s):
    """Tokenize a flat s-expression into a list of Python values.

    Handles escaped characters inside strings (\\\" â†’ \", \\\\ â†’ \\).
    Returns strings, integers, and None (for nil).
    """
    tokens = []
    i = 0
    while i < len(s):
        if s[i] in ' \t':
            i += 1
        elif s[i] == '"':
            # Parse quoted string with escape handling
            i += 1  # skip opening quote
            chars = []
            while i < len(s) and s[i] != '"':
                if s[i] == '\\' and i + 1 < len(s):
                    chars.append(s[i + 1])
                    i += 2
                else:
                    chars.append(s[i])
                    i += 1
            i += 1  # skip closing quote
            tokens.append(''.join(chars))
        elif s[i:i + 3] == 'nil':
            tokens.append(None)
            i += 3
        elif s[i].isdigit() or (s[i] == '-' and i + 1 < len(s) and s[i + 1].isdigit()):
            j = i + 1 if s[i] != '-' else i + 2
            while j < len(s) and s[j].isdigit():
                j += 1
            tokens.append(int(s[i:j]))
            i = j
        else:
            i += 1  # skip parens and other delimiters
    return tokens


def parse_result(line):
    """Parse a result line from org-ql output."""
    if line.startswith('(') and line.endswith(')'):
        tokens = _tokenize_sexp(line[1:-1])
        if len(tokens) == 8:
            heading, todo, priority, deadline, scheduled, filepath, lineno, org_id = tokens
            return {
                'heading': heading or '',
                'todo': todo,
                'priority': priority if priority and priority != 'B' else None,
                'deadline': deadline,
                'scheduled': scheduled,
                'file': filepath,
                'line': lineno if isinstance(lineno, int) else None,
                'id': org_id
            }
    return {'heading': line}


def format_task(task, idx=None, show_ids=False, show_handles=True, show_file=False,
                 idx_width=3, handle_width=0):
    """Format a task for display."""
    parts = []
    if idx is not None:
        parts.append(colorize(f"{idx:>{idx_width}d}", None, dim=True))

    if show_handles:
        handle = task.get("handle") or ""
        if handle_width:
            handle = f"{handle:<{handle_width}}"
        if handle.strip():
            parts.append(colorize(handle, None, dim=True))

    if task.get('todo'):
        todo = task['todo']
        todo_color = TODO_COLORS.get(todo)
        parts.append(colorize(f"[{todo:<7s}]", todo_color, bold=True))

    if task.get('priority'):
        priority = task['priority']
        pri_color = PRIORITY_COLORS.get(priority)
        parts.append(colorize(f"({priority})", pri_color, bold=True))

    parts.append(colorize(task.get('heading', ''), None, bold=True))

    deadline = format_date_label("DUE", task.get('deadline'))
    scheduled = format_date_label("SCH", task.get('scheduled'))
    if deadline:
        parts.append(deadline)
    if scheduled:
        parts.append(scheduled)

    if show_ids:
        org_id = task.get('id')
        if org_id:
            parts.append(colorize(f"ID:{org_id}", None, dim=True))
        else:
            parts.append(colorize("ID:", None, dim=True))

    if show_file:
        filepath = task.get('file')
        if filepath:
            parts.append(colorize(os.path.basename(filepath), None, dim=True))

    return ' '.join(parts)


def format_task_detail(task, idx=None):
    """Format a task with file/line details."""
    lines = []
    prefix = f"Task {idx}:" if idx is not None else "Task:"
    lines.append(prefix)
    heading = task.get('heading', '')
    todo = task.get('todo')
    priority = task.get('priority')
    if todo:
        heading = f"{colorize(f'[{todo}]', TODO_COLORS.get(todo), bold=True)} {heading}"
    if priority:
        heading = f"{colorize(f'({priority})', PRIORITY_COLORS.get(priority), bold=True)} {heading}"
    lines.append(f"  {colorize(heading, None, bold=True)}")
    if task.get('deadline'):
        lines.append(f"  Deadline: {format_date_value('DUE', task['deadline'])}")
    if task.get('scheduled'):
        lines.append(f"  Scheduled: {format_date_value('SCH', task['scheduled'])}")
    file_info = task.get('file')
    line_no = task.get('line')
    if file_info and line_no:
        lines.append(f"  Location: {colorize(f'{file_info}:{line_no}', None, dim=True)}")
    handle = task.get("handle")
    if handle:
        lines.append(f"  Handle: {handle}")
    if task.get("id"):
        lines.append(f"  ID: {task['id']}")
    return "\n".join(lines)


SORT_KEYS = {
    'priority': lambda t: ({'A': 0, 'B': 1, 'C': 2}.get(t.get('priority') or 'B', 1)),
    'due': lambda t: (parse_org_timestamp(t.get('deadline') or '')[0] or date.max).isoformat(),
    'scheduled': lambda t: (parse_org_timestamp(t.get('scheduled') or '')[0] or date.max).isoformat(),
    'heading': lambda t: (t.get('heading') or '').lower(),
}


def print_results(results, empty_msg="No tasks found.", show_ids=False, show_handles=True,
                  limit=None, sort_key=None, show_file=False):
    """Print formatted results."""
    if not results or (len(results) == 1 and not results[0]):
        print(empty_msg)
        return 0

    total = len(results)
    cache, tasks, updated = ensure_handles_for_results(results) if show_handles else (None, [parse_result(l) for l in results], False)
    if updated:
        save_handle_cache(cache)
    if sort_key and sort_key in SORT_KEYS:
        tasks.sort(key=SORT_KEYS[sort_key])
    display_tasks = tasks[:limit] if limit else tasks

    # Compute column widths for alignment
    idx_width = max(3, len(str(len(display_tasks))))
    handle_width = max((len(t.get('handle') or '') for t in display_tasks), default=0)

    for i, task in enumerate(display_tasks, 1):
        print(format_task(task, i, show_ids=show_ids, show_handles=show_handles,
                          show_file=show_file, idx_width=idx_width, handle_width=handle_width))

    if limit and limit < total:
        print(f"\nShowing {limit} of {total} task(s)")
    else:
        print(f"\n{total} task(s)")
    return total


def _resolve_query_from_filter(filter_args):
    """Map common filter shorthand (today/next/week) to an org-ql query string."""
    if not filter_args:
        return '(and (todo) (not (done)))'
    if filter_args[0] == 'today':
        return '(and (not (done)) (or (deadline :to today) (scheduled :to today) (ts-active :on today)))'
    if filter_args[0] == 'next':
        return '(or (todo "STRT") (and (todo "TODO") (priority "A")))'
    if filter_args[0] == 'week':
        return '(or (deadline :from today :to +7) (scheduled :from today :to +7))'
    return build_query(filter_args)


def _resolve_handle_or_fail(token):
    """Resolve a handle/org-id token or print an error. Returns org_id or None."""
    cache = load_handle_cache()
    resolved, candidates = resolve_id_token(token, cache)
    if candidates:
        print("Ambiguous handle prefix. Candidates:", file=sys.stderr)
        for cand in candidates:
            print(f"  {cand}", file=sys.stderr)
        return None
    if not resolved:
        print("Unknown handle. Run 'org-warrior handles-assign' or use full Org ID.", file=sys.stderr)
        return None
    return resolved


def _get_task_by_index(results, idx):
    """Validate index and return parsed task dict, or None on error."""
    if not results or (len(results) == 1 and not results[0]):
        print("No tasks found for the given filter.", file=sys.stderr)
        return None
    if idx < 1 or idx > len(results):
        print(f"Task ID {idx} out of range (1-{len(results)}).", file=sys.stderr)
        return None
    task = parse_result(results[idx - 1])
    if not task.get('file') or not task.get('line'):
        print("Error: could not determine task location.", file=sys.stderr)
        return None
    return task


def cmd_task(args):
    """Show details for a single task by index from the given query (default list)."""
    if not args:
        print("Usage: org-warrior task <id> [filters]", file=sys.stderr)
        return 1
    try:
        idx = int(args[0])
    except ValueError:
        print("Error: task id must be a number.", file=sys.stderr)
        return 1
    query = build_query(args[1:])
    results = run_org_ql(query, select="full")
    if idx < 1 or idx > len(results):
        print(f"Task id {idx} out of range (1-{len(results)}).", file=sys.stderr)
        return 1
    cache, tasks, updated = ensure_handles_for_results([results[idx - 1]])
    if updated:
        save_handle_cache(cache)
    print(format_task_detail(tasks[0], idx))
    return 0


def _parse_display_flags(args):
    """Parse common display flags from args.

    Returns dict with keys: show_ids, show_handles, limit, sort_key, show_file, args.
    """
    # Start with config-file defaults; CLI flags override
    cfg_limit = None
    if DEFAULT_LIMIT:
        try:
            cfg_limit = int(DEFAULT_LIMIT)
        except ValueError:
            pass
    flags = {
        'show_ids': CONFIG_SHOW_IDS,
        'show_handles': CONFIG_SHOW_HANDLES,
        'limit': cfg_limit,
        'sort_key': DEFAULT_SORT or None,
        'show_file': False,
    }
    remaining = list(args)
    while remaining:
        if remaining[0] in ('--ids', '--show-ids'):
            flags['show_ids'] = True
            remaining = remaining[1:]
        elif remaining[0] == '--no-handles':
            flags['show_handles'] = False
            remaining = remaining[1:]
        elif remaining[0] == '--limit' and len(remaining) > 1:
            try:
                flags['limit'] = int(remaining[1])
            except ValueError:
                print("Error: --limit requires a number.", file=sys.stderr)
            remaining = remaining[2:]
        elif remaining[0] == '--sort' and len(remaining) > 1:
            flags['sort_key'] = remaining[1]
            remaining = remaining[2:]
        elif remaining[0] == '--show-file':
            flags['show_file'] = True
            remaining = remaining[1:]
        else:
            break
    flags['args'] = remaining
    return flags


def cmd_list(args):
    """List tasks matching filters."""
    f = _parse_display_flags(args)
    query = build_query(f['args'])
    results = run_org_ql(query, select="full")
    print_results(results, show_ids=f['show_ids'], show_handles=f['show_handles'],
                  limit=f['limit'], sort_key=f['sort_key'], show_file=f['show_file'])
    return 0


def cmd_next(args):
    """Show next actions (NEXT keyword or high priority TODO)."""
    query = '(or (todo "STRT") (and (todo "TODO") (priority "A")))'
    results = run_org_ql(query, select="full")
    print_results(results, "No next actions found.")
    return 0


def cmd_today(args):
    """Show tasks due/scheduled up to today (overdue + today)."""
    f = _parse_display_flags(args)
    query = '(and (not (done)) (or (deadline :to today) (scheduled :to today) (ts-active :on today)))'
    results = run_org_ql(query, select="full")
    print_results(results, "No tasks for today.", show_ids=f['show_ids'], show_handles=f['show_handles'],
                  limit=f['limit'], sort_key=f['sort_key'], show_file=f['show_file'])
    return 0


def cmd_week(args):
    """Show tasks for the coming week."""
    f = _parse_display_flags(args)
    query = '(or (deadline :from today :to +7) (scheduled :from today :to +7))'
    results = run_org_ql(query, select="full")
    print_results(results, "No tasks for this week.", limit=f['limit'], sort_key=f['sort_key'], show_file=f['show_file'])
    return 0


def cmd_overdue(args):
    """Show overdue tasks."""
    query = '(and (not (done)) (deadline :to -1))'
    results = run_org_ql(query, select="full")
    print_results(results, "No overdue tasks.")
    return 0


def cmd_done(args):
    """Show recently completed tasks."""
    query = '(closed :from -7 :to today)'
    results = run_org_ql(query, select="full")
    print_results(results, "No recently completed tasks.")
    return 0


def cmd_projects(args):
    """Show active projects."""
    query = '(and (tags "project") (not (done)) (not (ancestors (tags "project"))))'
    results = run_org_ql(query, select="full")
    print_results(results, "No active projects.")
    return 0


def cmd_search(args):
    """Search tasks by text."""
    if not args:
        print("Usage: org-warrior search <pattern>", file=sys.stderr)
        return 1
    pattern = ' '.join(args)
    query = f'(regexp "{_escape_elisp(pattern)}")'
    results = run_org_ql(query, select="full")
    print_results(results, f"No tasks matching '{pattern}'.")
    return 0


def cmd_tag(args):
    """List tasks with a specific tag."""
    if not args:
        print("Usage: org-warrior tag <tagname>", file=sys.stderr)
        return 1
    tag = args[0]
    query = f'(and (not (done)) (tags "{_escape_elisp(tag)}"))'
    results = run_org_ql(query, select="full")
    print_results(results, f"No tasks with tag '{tag}'.")
    return 0


def cmd_priority(args):
    """List tasks by priority."""
    pri = args[0].upper() if args else "A"
    query = f'(and (not (done)) (priority "{_escape_elisp(pri)}"))'
    results = run_org_ql(query, select="full")
    print_results(results, f"No priority {pri} tasks.")
    return 0


def cmd_waiting(args):
    """Show waiting tasks."""
    query = '(todo "WAIT")'
    results = run_org_ql(query, select="full")
    print_results(results, "No waiting tasks.")
    return 0


def cmd_stuck(args):
    """Show stuck projects (projects without NEXT actions)."""
    query = '(and (tags "project") (not (done)) (not (ancestors (tags "project"))) (not (descendants (todo "STRT"))))'
    results = run_org_ql(query, select="full")
    print_results(results, "No stuck projects.")
    return 0


def cmd_open(args):
    """Open a task in Emacs by handle, org-id, or index."""
    if not args:
        print("Usage: org-warrior open <handle|org-id|index N [filters]>", file=sys.stderr)
        return 1

    if args[0] == 'index':
        if len(args) < 2:
            print("Usage: org-warrior open index <N> [filters]", file=sys.stderr)
            return 1
        try:
            idx = int(args[1])
        except ValueError:
            print("Error: index must be a number.", file=sys.stderr)
            return 1
        query = _resolve_query_from_filter(args[2:])
        results = run_org_ql(query, select="full")
        task = _get_task_by_index(results, idx)
        if not task:
            return 1
        filepath, lineno = task['file'], task['line']
    else:
        org_id = _resolve_handle_or_fail(args[0])
        if not org_id:
            return 1
        query = f'(property "ID" "{_escape_elisp(org_id)}")'
        results = run_org_ql(query, select="full")
        if not results or (len(results) == 1 and not results[0]):
            print(f"No entry found for ID {org_id}", file=sys.stderr)
            return 1
        task = parse_result(results[0])
        filepath = task.get('file')
        lineno = task.get('line')
        if not filepath or not lineno:
            print("Error: could not determine task location.", file=sys.stderr)
            return 1

    cmd = [EMACS_CMD, "-s", EMACS_SERVER, f"+{lineno}", filepath]
    try:
        # Open without blocking to avoid hanging if Emacs is busy; user can then interact with Emacs to open the file if needed
        subprocess.Popen(cmd)
    except subprocess.TimeoutExpired:
        print("Error: emacsclient timed out.", file=sys.stderr)
        return 1
    return 0


def cmd_count(args):
    """Print the number of tasks matching filters."""
    if not args:
        query = '(and (todo) (not (done)))'
    elif args[0] == 'today':
        query = '(and (not (done)) (or (deadline :to today) (scheduled :to today) (ts-active :on today)))'
    elif args[0] == 'week':
        query = '(or (deadline :from today :to +7) (scheduled :from today :to +7))'
    elif args[0] == 'overdue':
        query = '(and (not (done)) (deadline :to -1))'
    else:
        query = build_query(args)
    results = run_org_ql(query, select="full")
    count = len(results) if results and not (len(results) == 1 and not results[0]) else 0
    print(count)
    return 0


def cmd_query(args):
    """Run a raw org-ql query."""
    if not args:
        print("Usage: org-warrior query '<org-ql-expression>'", file=sys.stderr)
        return 1
    query = ' '.join(args)
    results = run_org_ql(query, select="full")
    print_results(results, "No results.")
    return 0


def cmd_start(args):
    """Clock in to a task by handle/org-id or by index from a filter context."""
    if not args:
        print("Usage: org-warrior start <filter> <task-index|handle|org-id>", file=sys.stderr)
        print("Example: org-warrior start today 1", file=sys.stderr)
        print("Example: org-warrior start alpha-lima-foxtrot", file=sys.stderr)
        return 1

    try:
        task_id = int(args[-1])
        is_org_id = False
        filter_args = args[:-1]
    except ValueError:
        org_id = _resolve_handle_or_fail(args[-1])
        if not org_id:
            return 1
        is_org_id = True

    if is_org_id:
        elisp = f'''(progn
          (require 'org)
          (require 'org-id)
          (let ((m (org-id-find "{_escape_elisp(org_id)}" t)))
            (if (not m)
                (princ "NOT_FOUND")
              (with-current-buffer (marker-buffer m)
                (goto-char m)
                (org-clock-in)
                (save-buffer)
                (princ (format "%s" (substring-no-properties (org-get-heading t t t t))))))))'''

        try:
            heading = emacs_eval(elisp).strip()
        except RuntimeError as e:
            print(f"Error clocking in: {e}", file=sys.stderr)
            return 1

        if heading == 'NOT_FOUND':
            print(f"No entry found for ID {org_id}", file=sys.stderr)
            return 1

        print(f"âœ“ Clocked in to task: {heading}")
        return 0

    query = _resolve_query_from_filter(filter_args)
    results = run_org_ql(query, select="full")
    task = _get_task_by_index(results, task_id)
    if not task:
        return 1

    filepath, lineno = task['file'], task['line']
    elisp = f'''(progn
      (find-file "{_escape_elisp(filepath)}")
      (goto-char (point-min))
      (forward-line {lineno - 1})
      (org-clock-in))'''

    cmd = [EMACS_CMD, "-s", EMACS_SERVER, "-e", elisp]

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=EMACS_TIMEOUT)
    except subprocess.TimeoutExpired:
        print("Error: emacsclient timed out.", file=sys.stderr)
        return 1

    if result.returncode != 0:
        print(f"Error clocking in: {result.stderr}", file=sys.stderr)
        return 1

    print(f"âœ“ Clocked in to task {task_id}: {task.get('heading')}")
    print("Tip: use handles for stable task references across operations.", file=sys.stderr)
    return 0


def _load_context():
    """Load active context filter from ~/.org-warrior/context."""
    if not os.path.isfile(CONTEXT_FILE):
        return None
    try:
        with open(CONTEXT_FILE, "r", encoding="utf-8") as fh:
            ctx = fh.read().strip()
        return ctx if ctx and ctx != "none" else None
    except OSError:
        return None


def _save_context(value):
    os.makedirs(CONFIG_DIR, exist_ok=True)
    with open(CONTEXT_FILE, "w", encoding="utf-8") as fh:
        fh.write(value + "\n")


def build_query(args):
    """Build org-ql query from TaskWarrior-like filters.

    Automatically prepends the active context filter if set.
    """
    ctx = _load_context()
    ctx_args = [ctx] if ctx else []

    if not args and not ctx_args:
        return '(and (todo) (not (done)))'

    all_args = ctx_args + list(args or [])
    conditions = ['(not (done))']
    args = all_args
    
    for arg in args:
        if arg.startswith('+'):
            conditions.append(f'(tags "{_escape_elisp(arg[1:])}")')
        elif arg.startswith('project:'):
            conditions.append('(ancestors (tags "project"))')
        elif arg.startswith('pri:') or arg.startswith('priority:'):
            pri = arg.split(':')[1].upper()
            conditions.append(f'(priority "{_escape_elisp(pri)}")')
        elif arg.startswith('due:'):
            due = arg.split(':')[1]
            if due == 'today':
                conditions.append('(deadline :on today)')
            elif due == 'week':
                conditions.append('(deadline :from today :to +7)')
            elif due == 'overdue':
                conditions.append('(deadline :to -1)')
        elif arg.startswith('scheduled:'):
            sched = arg.split(':')[1]
            if sched == 'today':
                conditions.append('(scheduled :on today)')
        else:
            conditions.append(f'(regexp "{_escape_elisp(arg)}")')
    
    if len(conditions) == 1:
        return conditions[0]
    return f'(and {" ".join(conditions)})'


def emacs_eval(elisp: str) -> str:
    """Evaluate ELisp in the running Emacs daemon and return stdout (stripped)."""
    cmd = [EMACS_CMD, "-s", EMACS_SERVER, "-e", elisp]
    try:
        r = subprocess.run(cmd, capture_output=True, text=True, timeout=EMACS_TIMEOUT)
    except subprocess.TimeoutExpired:
        raise RuntimeError('emacsclient timed out (Emacs may be busy or waiting for input)')
    if r.returncode != 0:
        raise RuntimeError((r.stderr or '').strip() or 'emacsclient eval failed')
    out = (r.stdout or '').strip()
    # emacsclient prints strings with quotes
    if out.startswith('"') and out.endswith('"'):
        out = out[1:-1]
    return _unescape_elisp_string(out)


def cmd_show(args):
    """Show a task by Org ID (preferred) or by list index (fallback)."""
    if not args:
        print("Usage: org-warrior show <HANDLE|ORG-ID> | show index <n> [filters]", file=sys.stderr)
        return 1
    if args[0] == 'index':
        return cmd_task(args[1:])
    org_id = _resolve_handle_or_fail(args[0])
    if not org_id:
        return 1
    # org-ql property query (fast, avoids org-id global scan)
    query = f'(property "ID" "{org_id}")'
    results = run_org_ql(query, select="full")
    if not results or (len(results) == 1 and not results[0]):
        print(f"No entry found for ID {org_id}", file=sys.stderr)
        return 1
    cache, tasks, updated = ensure_handles_for_results([results[0]])
    if updated:
        save_handle_cache(cache)
    print(format_task_detail(tasks[0]))
    return 0


def cmd_add(args):
    """Add a new TODO to ~/org/inbox.org under 'Inbox' and create an org ID."""
    if not args:
        print("Usage: org-warrior add <title>", file=sys.stderr)
        return 1
    title = _escape_elisp(' '.join(args))
    elisp = rf"""(progn
      (require 'org)
      (require 'org-id)
      (let* ((file (expand-file-name "~/org/inbox.org"))
             (heading "Inbox"))
        (find-file file)
        (goto-char (point-min))
        (unless (re-search-forward (format "^\\*+ %s\\b" (regexp-quote heading)) nil t)
          (goto-char (point-max))
          (insert (format "* %s\n" heading)))
        (org-end-of-subtree t t)
        (unless (bolp) (insert "\n"))
        (let ((pos (point)))
          (insert (format "** TODO %s\n" "{title}"))
          (goto-char pos)
          (org-id-get-create)
          (save-buffer)
          (princ (org-id-get)))))"""
    new_id = emacs_eval(elisp).strip()
    cache = load_handle_cache()
    wordlist = load_wordlist()
    handle, created = ensure_handle_for_uuid(new_id, cache, wordlist)
    if created:
        save_handle_cache(cache)
    git_commit_org(f"org-warrior: add {new_id}")
    print(f"Created: {handle} (ID: {new_id})")
    return 0


def cmd_set_state(args):
    """Set TODO state for an entry by Org ID."""
    if len(args) < 2:
        print("Usage: org-warrior set-state <HANDLE|ORG-ID> <STATE>", file=sys.stderr)
        return 1
    org_id = _resolve_handle_or_fail(args[0])
    if not org_id:
        return 1
    state = args[1]
    elisp = rf"""(progn
      (require 'org)
      (require 'org-id)
      (let ((m (org-id-find "{_escape_elisp(org_id)}" t)))
        (if (not m)
            (princ "NOT_FOUND")
          (with-current-buffer (marker-buffer m)
            (goto-char m)
            (org-todo "{_escape_elisp(state)}")
            (save-buffer)
            (princ "OK")))))"""
    out = emacs_eval(elisp).strip()
    if out == 'NOT_FOUND':
        print(f"No entry found for ID {org_id}", file=sys.stderr)
        return 1
    git_commit_org(f"org-warrior: set-state {org_id} {state}")
    print("âœ“ Updated")
    return 0


def cmd_schedule(args):
    """Schedule a task by filter and ID (e.g., org-warrior schedule "6pm" today 1) or by Org ID."""
    if len(args) < 2:
        print("Usage: org-warrior schedule <DATE> [filter...] <task-index|handle|org-id>", file=sys.stderr)
        print("Example: org-warrior schedule \"6pm\" today 1", file=sys.stderr)
        print("Example: org-warrior schedule \"+1d\" +work 2", file=sys.stderr)
        print("Example: org-warrior schedule \"6pm\" abc123def456", file=sys.stderr)
        return 1

    date = args[0].replace('"', '')

    # Check if last argument is an Org ID (not an integer)
    try:
        task_id = int(args[-1])
        is_org_id = False
        filter_args = args[1:-1]
    except ValueError:
        org_id = _resolve_handle_or_fail(args[-1])
        if not org_id:
            return 1
        is_org_id = True

    if is_org_id:
        elisp = f'''(progn
          (require 'org)
          (require 'org-id)
          (let ((m (org-id-find "{_escape_elisp(org_id)}" t)))
            (if (not m)
                (princ "NOT_FOUND")
              (with-current-buffer (marker-buffer m)
                (goto-char m)
                (let ((d (format-time-string "%Y-%m-%d %H:%M" (org-read-date nil t "{_escape_elisp(date)}"))))
                  (org-schedule nil d))
                (save-buffer)
                (princ (format "%s" (substring-no-properties (org-get-heading t t t t))))))))'''

        try:
            heading = emacs_eval(elisp).strip()
        except RuntimeError as e:
            print(f"Error scheduling: {e}", file=sys.stderr)
            return 1

        if heading == 'NOT_FOUND':
            print(f"No entry found for ID {org_id}", file=sys.stderr)
            return 1

        print(f"âœ“ Scheduled task: {heading}")
        return 0

    # Numeric index path
    query = _resolve_query_from_filter(filter_args)
    results = run_org_ql(query, select="full")
    task = _get_task_by_index(results, task_id)
    if not task:
        return 1

    filepath, lineno = task['file'], task['line']
    elisp = f'''(progn
      (find-file "{_escape_elisp(filepath)}")
      (goto-char (point-min))
      (forward-line {lineno - 1})
      (let ((d (format-time-string "%Y-%m-%d %H:%M" (org-read-date nil t "{_escape_elisp(date)}"))))
        (org-schedule nil d))
      (save-buffer))'''

    cmd = [EMACS_CMD, "-s", EMACS_SERVER, "-e", elisp]

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=EMACS_TIMEOUT)
    except subprocess.TimeoutExpired:
        print("Error: emacsclient timed out.", file=sys.stderr)
        return 1

    if result.returncode != 0:
        print(f"Error scheduling: {result.stderr}", file=sys.stderr)
        return 1

    print(f"âœ“ Scheduled task {task_id}: {task.get('heading')}")
    print("Tip: use handles for stable task references across operations.", file=sys.stderr)
    return 0


def cmd_deadline(args):
    """Set a deadline for a task by filter and ID or by Org ID."""
    if len(args) < 2:
        print("Usage: org-warrior deadline <DATE> [filter...] <task-index|handle|org-id>", file=sys.stderr)
        print("Example: org-warrior deadline \"friday\" today 1", file=sys.stderr)
        print("Example: org-warrior deadline \"+7d\" +work 2", file=sys.stderr)
        print("Example: org-warrior deadline \"friday\" abc123def456", file=sys.stderr)
        return 1

    date = args[0].replace('"', '')

    # Check if last argument is an Org ID (not an integer)
    try:
        task_id = int(args[-1])
        is_org_id = False
        filter_args = args[1:-1]
    except ValueError:
        org_id = _resolve_handle_or_fail(args[-1])
        if not org_id:
            return 1
        is_org_id = True

    if is_org_id:
        elisp = f'''(progn
          (require 'org)
          (require 'org-id)
          (let ((m (org-id-find "{_escape_elisp(org_id)}" t)))
            (if (not m)
                (princ "NOT_FOUND")
              (with-current-buffer (marker-buffer m)
                (goto-char m)
                (let ((d (org-read-date nil nil "{_escape_elisp(date)}")))
                  (org-deadline nil d))
                (save-buffer)
                (princ (format "%s" (substring-no-properties (org-get-heading t t t t))))))))'''

        try:
            heading = emacs_eval(elisp).strip()
        except RuntimeError as e:
            print(f"Error setting deadline: {e}", file=sys.stderr)
            return 1

        if heading == 'NOT_FOUND':
            print(f"No entry found for ID {org_id}", file=sys.stderr)
            return 1

        git_commit_org(f"org-warrior: deadline {heading} {date}")
        print(f"âœ“ Set deadline for task: {heading}")
        return 0

    # Numeric index path
    query = _resolve_query_from_filter(filter_args)
    results = run_org_ql(query, select="full")
    task = _get_task_by_index(results, task_id)
    if not task:
        return 1

    filepath, lineno = task['file'], task['line']
    elisp = f'''(progn
      (find-file "{_escape_elisp(filepath)}")
      (goto-char (point-min))
      (forward-line {lineno - 1})
      (let ((d (org-read-date nil nil "{_escape_elisp(date)}")))
        (org-deadline nil d))
      (save-buffer))'''

    cmd = [EMACS_CMD, "-s", EMACS_SERVER, "-e", elisp]

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=EMACS_TIMEOUT)
    except subprocess.TimeoutExpired:
        print("Error: emacsclient timed out.", file=sys.stderr)
        return 1

    if result.returncode != 0:
        print(f"Error setting deadline: {result.stderr}", file=sys.stderr)
        return 1

    git_commit_org(f"org-warrior: deadline {task.get('heading')} {date}")
    print(f"âœ“ Set deadline for task {task_id}: {task.get('heading')}")
    print("Tip: use handles for stable task references across operations.", file=sys.stderr)
    return 0


def cmd_context(args):
    """Get or set persistent context filter."""
    if not args:
        ctx = _load_context()
        if ctx:
            print(f"Active context: {ctx}")
        else:
            print("No active context.")
        return 0
    value = args[0]
    if value == "none":
        if os.path.isfile(CONTEXT_FILE):
            os.unlink(CONTEXT_FILE)
        print("Context cleared.")
        return 0
    _save_context(value)
    print(f"Context set: {value}")
    return 0


def cmd_modify(args):
    """Apply an action to all tasks matching filters.

    Usage: org-warrior modify <filters...> set-state <STATE>
    """
    if len(args) < 2:
        print("Usage: org-warrior modify <filters...> set-state <STATE>", file=sys.stderr)
        return 1
    # Find the action keyword
    action_idx = None
    for i, a in enumerate(args):
        if a == "set-state" and i + 1 < len(args):
            action_idx = i
            break
    if action_idx is None:
        print("Error: only 'set-state <STATE>' is currently supported.", file=sys.stderr)
        return 1

    filter_args = args[:action_idx]
    state = args[action_idx + 1]
    query = build_query(filter_args) if filter_args else '(and (todo) (not (done)))'
    results = run_org_ql(query, select="full")
    if not results or (len(results) == 1 and not results[0]):
        print("No matching tasks.", file=sys.stderr)
        return 1

    cache, tasks, updated = ensure_handles_for_results(results)
    if updated:
        save_handle_cache(cache)
    print(f"Will set state to {state} for {len(tasks)} task(s):")
    for i, t in enumerate(tasks, 1):
        print(f"  {i}. {t.get('heading', '')}")
    answer = input("Proceed? [y/N] ").strip().lower()
    if answer != "y":
        print("Aborted.")
        return 0

    ok = 0
    for t in tasks:
        org_id = t.get("id")
        if not org_id:
            print(f"  Skipping (no ID): {t.get('heading', '')}", file=sys.stderr)
            continue
        elisp = rf"""(progn
          (require 'org) (require 'org-id)
          (let ((m (org-id-find "{_escape_elisp(org_id)}" t)))
            (if (not m) (princ "NOT_FOUND")
              (with-current-buffer (marker-buffer m)
                (goto-char m)
                (org-todo "{_escape_elisp(state)}")
                (save-buffer)
                (princ "OK")))))"""
        try:
            out = emacs_eval(elisp).strip()
            if out == "OK":
                ok += 1
            else:
                print(f"  Not found: {t.get('heading', '')}", file=sys.stderr)
        except RuntimeError as e:
            print(f"  Error: {e}", file=sys.stderr)
    git_commit_org(f"org-warrior: modify set-state {state} ({ok} tasks)")
    print(f"âœ“ Updated {ok} of {len(tasks)} task(s).")
    return 0


def cmd_jira_sync(args):
    """Trigger org-jira sync inside Emacs. NOTE: hits external Jira service."""
    elisp = """(progn (require 'org-jira) (org-jira-get-issues) (princ "OK"))"""
    out = emacs_eval(elisp).strip()
    print("âœ“ Jira sync triggered" if out == 'OK' else out)
    return 0


def cmd_handles_assign(args):
    """Scan org files for existing IDs and populate handle cache."""
    if args:
        print("Usage: org-warrior handles-assign", file=sys.stderr)
        print("  Scans org files for existing IDs and caches handles.", file=sys.stderr)
        print("  Warns about headings without IDs (use Emacs hooks to create them).", file=sys.stderr)
        return 1
    scan_and_cache_handles()
    return 0


def print_help():
    """Print usage help."""
    help_text = """
org-warrior - TaskWarrior-like interface for org-ql

USAGE:
    org-warrior [-f <file>] <command> [options]

COMMANDS:
  Read:
    list [filters] [options]    List tasks (default command)
    today [options]             Tasks due/scheduled today (includes overdue)
    week [options]              Tasks for the coming week
    next                        Next actions (STRT or priority A TODO)
    overdue                     Overdue deadline tasks
    done                        Recently completed tasks (last 7 days)
    projects                    Active projects
    stuck                       Stuck projects (no NEXT actions)
    waiting                     Waiting tasks
    tag <name>                  Tasks with specific tag
    priority <A|B|C>            Tasks by priority
    search <pattern>            Search tasks by text (regexp)
    query <expr>                Run raw org-ql expression
    count [today|week|overdue|filters]  Print number of matching tasks
    show <handle|org-id>        Show task details
    task <id> [filters]         Show task details by numeric index
    open <handle|org-id>        Open task in Emacs
    open index <N> [filters]    Open Nth task from filter in Emacs

  Write:
    add <title>                 Add new TODO to ~/org/inbox.org
    set-state <handle|org-id> <STATE>  Set TODO state
    schedule <date> [filter] <id|handle>  Schedule a task
    deadline <date> [filter] <id|handle>  Set deadline
    start [filter] <id>         Clock in to a task by numeric index
    modify <filters> set-state <STATE>  Bulk set state for matching tasks

  Meta:
    context [<filter>|none]     Get/set persistent context filter
    handles-assign              Scan org files and cache handles
    jira-sync                   Trigger org-jira sync

CONCEPTS:
    handle      Deterministic 3-word name derived from Org ID (e.g., paper-salmon-quiet).
                Case insensitive, supports unique prefix matching.
    org-id      UUID stored as :ID: property on Org headings. Stable across operations.
    index       Numeric position in a filtered list (1-based). Unstable across operations.

    Prefer handles or org-ids for write operations. Numeric indices may shift
    after any modification.

OPTIONS:
    -f, --file <path>    Restrict queries to a single org file
    --no-color           Disable colored output (also supports NO_COLOR env)
    --ids, --show-ids    Show Org IDs in output
    --no-handles         Hide handles in output
    --limit N            Show only first N tasks
    --sort <key>         Sort by: priority, due, scheduled, heading
    --show-file          Show source filename for each task

FILTERS:
    +tag              Filter by tag
    project:          Filter to project subtasks
    pri:A             Filter by priority (A, B, C)
    due:today         Due today
    due:week          Due this week
    due:overdue       Overdue items
    scheduled:today   Scheduled today
    <text>            Text search (regexp)

CONFIG:
    ~/.org-warrior/config   INI config file (optional)

    [core]
    files = ~/org           # Same as ORG_WARRIOR_FILES
    server = edit           # Same as ORG_WARRIOR_SERVER
    emacs_cmd = emacsclient # Same as EMACS_CMD

    [display]
    default_sort =          # Default sort key
    default_limit =         # Default limit
    color = auto            # auto, true, false
    show_handles = true
    show_ids = false

    Env vars override config; CLI flags override both.

ENVIRONMENT:
    ORG_WARRIOR_FILES   Path(s) to org files/directories (default: ~/org)
    EMACS_CMD           Emacs client command (default: emacsclient)
    ORG_WARRIOR_SERVER  Emacs server name (default: edit)

EXAMPLES:
    org-warrior                                   # List all open tasks
    org-warrior list --limit 5 --sort priority    # Top 5 by priority
    org-warrior today --show-file                 # Today's tasks with filenames
    org-warrior count today                       # Number for status bar
    org-warrior open paper-salmon-quiet           # Open in Emacs
    org-warrior context +work                     # Set persistent filter
    org-warrior list                              # Now filtered to +work
    org-warrior context none                      # Clear filter
    org-warrior modify +old set-state DONE        # Bulk complete tasks
    org-warrior -f ~/org/inbox.org list           # Single file
    org-warrior schedule "tomorrow" paper-salmon  # Schedule by handle prefix
    org-warrior deadline "friday" +work 2         # Deadline by index

SETUP (Required for handles):
    Add to your Emacs config (~/.doom.d/config.el for Doom):

        (defun org-warrior/ensure-ids-on-save ()
          (when (eq major-mode 'org-mode)
            (save-excursion
              (org-map-entries
               (lambda () (unless (org-id-get) (org-id-get-create)))))))

        (add-hook 'before-save-hook 'org-warrior/ensure-ids-on-save)

    Then save your org files to generate IDs, and run: org-warrior handles-assign
"""
    print(help_text.strip())


def main():
    args = sys.argv[1:]
    
    if not args or args[0] in ['-h', '--help', 'help']:
        print_help()
        return

    if args[0] == '--no-color' or CONFIG_COLOR == "false":
        set_color_mode(False)
        args = args[1:]
    else:
        set_color_mode(True)

    # Global --file / -f flag: restrict queries to a single file
    global ORG_FILES
    for i, a in enumerate(args):
        if a in ('-f', '--file'):
            if i + 1 >= len(args):
                print("Error: --file requires a path argument.", file=sys.stderr)
                sys.exit(1)
            fpath = os.path.expanduser(args[i + 1])
            if not os.path.isfile(fpath):
                print(f"Error: file not found: {fpath}", file=sys.stderr)
                sys.exit(1)
            ORG_FILES = fpath
            args = args[:i] + args[i + 2:]
            break

    commands = {
        'list': cmd_list,
        'show': cmd_show,
        'task': cmd_task,
        'next': cmd_next,
        'today': cmd_today,
        'week': cmd_week,
        'overdue': cmd_overdue,
        'done': cmd_done,
        'projects': cmd_projects,
        'stuck': cmd_stuck,
        'waiting': cmd_waiting,
        'tag': cmd_tag,
        'priority': cmd_priority,
        'search': cmd_search,
        'query': cmd_query,
        'count': cmd_count,
        'open': cmd_open,
        'start': cmd_start,
        'schedule': cmd_schedule,
        'deadline': cmd_deadline,
        'jira-sync': cmd_jira_sync,
        'handles-assign': cmd_handles_assign,
        'context': cmd_context,
        'modify': cmd_modify,
        'add': cmd_add,
    }
    
    cmd = args[0]
    cmd_args = args[1:]

    if cmd in commands:
        rc = commands[cmd](cmd_args)
    else:
        rc = cmd_list(args)
    sys.exit(rc or 0)


if __name__ == '__main__':
    main()
